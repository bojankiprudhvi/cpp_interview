Ipc
Shared memory
2pc communication
Thread
Sync
Deadlock
Udp socket
How we use linux envoirment
Constant pointer
Array vs vector
Map
Malloc vs cpp
New -malloc
Which cpp worked-C++11 C++14
Constant pointers
Size of class
Destructor
virtual ``	
pure virtual
abstract class
Inheritance
Dynamic memory allocation(new delete)



Abstraction
Encapsulation
Class design	

Design pattern
Constructor- types
templets






class diagram
design pattern 
stl concepts
project knowledge
oops concepts 
abstraction and pure abstraction
virtual concepts
friend
operator and function over loading and over riding




c++ interview

ipc (inter process communication)
luna message response writign and passign back to aplication using semaphore

thread
pthread.h

pthread_t thread_name
sem_t sem_name
pthread_create(&thread_name,NULL,&void fun,null)
sem_init(&read_sem,0,0);


ffi 
libwebos_luna_bridge_handle = dlopen(webos_luna_bridge.c_str(), RTLD_LOCAL | RTLD_NOW);

      if (libwebos_luna_bridge_handle != NULL)
      {
        webosLunaBridgeRegister = (int (*)())dlsym(libwebos_luna_bridge_handle, "webosLunaBridgeRegister");
        webosLunaSyncCall = (char *(*)(char *uri, char *args, char *ctx, char *appId))dlsym(libwebos_luna_bridge_handle, "webosLunaSyncCall");
		
		
smart poiner->
dealocation is tacken care my itself

1)uniqu poiner(std::unique_ptr<data type>)- only one poineter can to poinet to that memory location
2)shared poineter (shared_ptr<data typ	e>)- two or more pointer can share the same memory
3)weak_ptr will not hold the refernce 


vector
#include <vector>
 vector<int> g1;
 g1.push_back(i);
  for (auto i = g1.begin(); i != g1.end(); ++i)
        cout << *i << " ";
		
size() â€“ Returns the number of elements in the vector.

Map
#include <map>

map<string, int> mp;
    mp["one"] = 1;
    mp["two"] = 2;
    mp["three"] = 3;
    map<string, int>::iterator it = mp.begin();
    while (it != mp.end()) {
        cout << "Key: " << it->first	
             << ", Value: " << it->second << endl;
        ++it;
    }


pointer 
 pointer to constant 
 const int* score{ &high };
 
 const pointer
 int* const ptr{ &a };
 
 const pointer to const
 
 const int a{ 50 };
    const int b{ 90 };
 
    // ptr points to a
    const int* const ptr{ &a };
	
	
size of the class by default 1 so the the odject when created can store the addres sof the class.

When is the destructor called?
A destructor function is called automatically when the object goes out of scope:

the function ends 
the program ends 
a block containing local variables ends 
a delete operator is called  


virtual destructor
Making base class destructor virtual guarantees that the object of derived class is destructed properly, i.e., both base class and derived class destructors are called. For example, 

Encapsulation
getdata 
set data
 
 
 
 interview 1(adagrad ai)
 
 notification when a obj is beign destroyed
 smart pointers
 program to find whether a array is becoming sored when on element is removed form it
 program to find the sum of diagnold in a square matrix
 docker

interview 2(tcs)
liked list program
finding center on linked list(solution using two pointers)
avoiding the blocking of i/o using system calls (fork())
sequirity breach in c++
make file structure and usage
jenkins
git commands (diff)
linux commands (lsof,some more not answered)
socket basic
finding memory leak with out using any tools( top command)
top command with parametres
register in c



interview 3 (dover)
copy constructor wrtign 
relitins betwween classs( conjection and all)
thread in c++
smart pointers unique pointers sharing 

 
 Association, Composition and Aggregation in C++

association one class depends on other calls object 

composition - one classs object is creacteed inside the ortehr class. one class life time depends on otehr class
aggregation - same as composition but both or independent
lambda fucntionn 


auto F = [](int x){
# statements

};


 thread in c++
std::thread thread_obj(&Base::foo, &b, params);


interview(4) xoirinet
linked list delete node
danglign pointer
memory structure(stack memory heap mempry for global and local vareibale)
why virtual 
virtual Inheritance
volatile
        A virtual int A()
      /  \
   A()B  C A()
      \ /
        D
ipc communication


ust global
about project

write a progeam to reverse each word in the sentance using pointers'

semaphore where we used and how multi threads worked

