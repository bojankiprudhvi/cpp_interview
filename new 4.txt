Ipc
Shared memory
2pc communication
Thread
Sync
Deadlock
Udp socket
How we use linux envoirment
Constant pointer
Array vs vector
Map
Malloc vs cpp
New -malloc
Which cpp worked-C++11 C++14
Constant pointers
Size of class
Destructor
virtual ``	
pure virtual
abstract class
Inheritance
Dynamic memory allocation(new delete)



Abstraction
Encapsulation
Class design	

Design pattern
Constructor- types
templets




c++ interview

ipc (inter process communication)
luna message response writign and passign back to aplication using semaphore

thread
pthread.h

pthread_t thread_name
sem_t sem_name
pthread_create(&thread_name,NULL,&void fun,null)
sem_init(&read_sem,0,0);


ffi 
libwebos_luna_bridge_handle = dlopen(webos_luna_bridge.c_str(), RTLD_LOCAL | RTLD_NOW);

      if (libwebos_luna_bridge_handle != NULL)
      {
        webosLunaBridgeRegister = (int (*)())dlsym(libwebos_luna_bridge_handle, "webosLunaBridgeRegister");
        webosLunaSyncCall = (char *(*)(char *uri, char *args, char *ctx, char *appId))dlsym(libwebos_luna_bridge_handle, "webosLunaSyncCall");
		
		
smart poiner->
dealocation is tacken care my itself

1)uniqu poiner(std::unique_ptr<data type>)- only one poineter can to poinet to that memory location
2)shared poineter (shared_ptr<data type>)- two or more pointer can share the same memory
3)weak_ptr will not hold the refernce 


vector
#include <vector>
 vector<int> g1;
 g1.push_back(i);
  for (auto i = g1.begin(); i != g1.end(); ++i)
        cout << *i << " ";
		
size() â€“ Returns the number of elements in the vector.

Map
#include <map>

map<string, int> mp;
    mp["one"] = 1;
    mp["two"] = 2;
    mp["three"] = 3;
    map<string, int>::iterator it = mp.begin();
    while (it != mp.end()) {
        cout << "Key: " << it->first	
             << ", Value: " << it->second << endl;
        ++it;
    }


pointer 
 pointer to constant 
 const int* score{ &high };
 
 const pointer
 int* const ptr{ &a };
 
 const pointer to const
 
 const int a{ 50 };
    const int b{ 90 };
 
    // ptr points to a
    const int* const ptr{ &a };
	
	
size of the class by default 1 so the the odject when created can store the addres sof the class.

When is the destructor called?
A destructor function is called automatically when the object goes out of scope:

the function ends 
the program ends 
a block containing local variables ends 
a delete operator is called  


virtual destructor
Making base class destructor virtual guarantees that the object of derived class is destructed properly, i.e., both base class and derived class destructors are called. For example, 

Encapsulation
getdata 
set data
 
 
 
 interview 1(adagrad ai)
 
 notification when a obj is beign destroyed
 smart pointers
 program to find whether a array is becoming sored when on element is removed form it
 program to find the sum of diagnold in a square matrix
 docker
 
 
 